/*
 * parseconfig.c -- parse the config file
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//#include <autoconfig.h> // this file generated by automake


// str_split_char -- a non-reentry function
// remember to release it when it's useless
char **str_split_char(char *str, const char *split)
{
	char **pptr = NULL;
	char *pstr;
	char *savestr;
	char *token;
	int i;
	pptr = (char **)malloc(sizeof(char **) * array_size);
	if (pptr == NULL) {
		fprintf(stderr, "Failed to allocate the room.\n");
		return NULL;
	}
	memset(pptr, 0, sizeof(char **) * array_size);

	for (pstr = str, i = 0; ; i++, pstr = NULL) {
		token = strtok_r(pstr, split, &savestr);
		if (token == NULL)
			break;
		pptr[i] = token;
	}
	pptr[i] = NULL;

	return pptr;

}

void load_setting(const char *p_setting)
{
	char **ptr = NULL;
	const struct parseconf_str_setting *p_str_setting;
	p_str_setting = parseconf_str_array;
	int retval;

	// We get the input string in a syle of  x = xxx,
	// we need split them out
	while (p_str_setting->p_setting_name != 0) {
		ptr = str_split_char(p_setting, "=");
		if (ptr == NULL) {
			fprintf(stderr, "Failed to parse the line.\n");
			exit(1);
		}
		retval = strcmp(p_str_setting->p_setting_name, ptr[0]);
		if (retval == 0) {
			const char **p_curr_setting = p_str_setting->p_variable;
			// We should do a check that if the pointer is not null,
			// we should release the old one.
			if (*p_curr_setting != NULL) {
				free((char *) *p_curr_setting);
			}

			if (ptr[1] == NULL) {
				*p_curr_setting = NULL;
			} else {

				*p_curr_setting = strdup(ptr[1]);
			}

			free(ptr);
			return;
		}

		p_str_setting++;

	}
	// Do not forget free the room when it useless
	free(ptr);

}

/*
 * get_word -- extract word from a line
 */
void get_word(char *line)
{
	char *ptr;
	ptr = line;
	char word[32];
	int i, j;

	j = 0;

	while (*ptr != '\0') {
		// We should clear the buf and counter
		bzero(word, sizeof(word));
		i = 0;
		while (('A' <= *ptr && *ptr <= 'Z') || ('a' <= *ptr &&
		    *ptr <= 'z')) {
			word[i] = *ptr;
			i++;
			ptr++;
		}
		if (word[0] != 0) {
			printf("%s\n", word);
			j++;
		}
		ptr++;

	}
	printf("The total number is %d\n", j);

}

/*
 * get_number -- extract number from a line
 */
void get_number(char *line)
{
	char *ptr;
	ptr = line;
	char num[32];
	int i, j;

	j = 0;

	while (*ptr != '\0') {
		// We should clear the buf and counter
		bzero(num, sizeof(num));
		i = 0;
		while ('0' <= *ptr && *ptr <= '9') {
			num[i] = *ptr;
			i++;
			ptr++;
		}
		if (num[0] != 0) {
			printf("%s\n", num);
			j++;
		}
		ptr++;

	}
	printf("The total number is %d\n", j);

}

/*
 * get_comment -- extract comments from aline
 */
void get_comment(char *line)
{
	char *ptr;
	ptr = line;
	char comment[1024];
	int i, j;

	j = 0;

	while (*ptr != '\0') {
		// We should clear the buf and counter
		bzero(comment, sizeof(comment));
		i = 0;
		if (*ptr == '#') {
			while (*ptr != '\n') {
				comment[i] = *ptr;
				i++;
				ptr++;
				if (*ptr == '\0')
					break;
			}
		}
		if (comment[0] != 0) {
			printf("%s\n", comment);
			j++;
		}
		ptr++;

	}
	printf("The total comment is %d\n", j);

}

/*
 * clean_space -- clean all space of a line
 */
char *clean_space(char *line)
{
	size_t len = strlen(line);
	//At least, our buf should not small than the line
	char *buf = (char *)malloc(len + 1);
	char *ptr;
	ptr = line;
	int i = 0;

	// XXX It's very import to zero the buf
	memset(buf, 0, len + 1);
	while (*ptr != '\0') {
		while (*ptr == ' ') {
			ptr++;
			if (*(ptr + 1) == '\0')
				break;
		}
		buf[i] = *ptr;
		ptr++;
		i++;

	}

	return buf;
}

/*
 * clean_comment -- clean all comment of a line
 */
char *clean_comment(char *line)
{
	size_t len = strlen(line);
	//At least, our buf should not small than the line
	char *buf = (char *)malloc(len + 1);
	char *ptr;
	ptr = line;
	int i = 0;

	// XXX It's very import to zero the buf
	memset(buf, 0, len + 1);
	while (*ptr != '\0') {
		if (*ptr == '#')
			break;

		buf[i] = *ptr;
		ptr++;
		i++;

	}
	ptr = buf;

	return ptr;
}

// read_file, read full of file contents and
// store into buf
char *read_file(const char *filename)
{
	int fd;
	struct stat file_info;
	char *buffer;
	size_t len;
	/*  Open the file */
	fd = open(filename, O_RDONLY);
	if (fd < 0) {
		fprintf(stderr, "Failed to open the file!\n");
		exit(-1);
	}
	/* Get infomation about the file */
	fstat(fd, &file_info);
	len = file_info.st_size;
	//printf("The length of file is %d\n", len);
	/* Make sure the file is an ordinary file. */
	if (!S_ISREG(file_info.st_mode)) {
		close(fd);
		return NULL;
	}
	/* Allocate a buffer large enough to hold the file's contents. */
	buffer = (char *)malloc(len);
	/* Read the file into the buffer. */
	read(fd, buffer, len);
	close(fd);
	return buffer;
}

// parse buf into lines
void parse_file(char *buf)
{
	char *str1, *str2, *token;
	char *saveptr1;
	// We need the i to keep loop
	for (str1 = buf; ; str1 = NULL) {
		token = strtok_r(str1, "\n", &saveptr1);
		if (token == NULL)
			break;
		// Now, we get a line, then let's process it with
		// funcions in getword
		str1 = clean_comment(token);
		str2 = clean_space(str1);
		if (str2[0] != '\0') {
                        //printf("The newline is %s\n", str2);
                        load_setting(str2);
		}
		free(str2);
		free(str1);
	}

}

