/*
 * parseconfig.c -- parse the config file
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
//#include <autoconfig.h> // this file generated by automake


/* 
 * str_split_char -- a non-reentry function
 * remember to release it when it's useless
 */
char **str_split_char(char *str, const char *split)
{
	char **pptr = NULL;
	char *pstr;
	char *savestr;
	char *token;
	int i;
	int len;
	// First, check the length of input string
	len = strlen(str);
	// We also need a room for end null pointer
	pptr = (char **)malloc(sizeof(char **) * (len + 1));
	if (pptr == NULL) {
		fprintf(stderr, "Failed to allocate the room.\n");
		return NULL;
	}
	memset(pptr, 0, sizeof(char **) * (len + 1));

	for (pstr = str, i = 0; ; i++, pstr = NULL) {
		token = strtok_r(pstr, split, &savestr);
		if (token == NULL)
			break;
		pptr[i] = token;
	}
	pptr[i] = NULL;

	return pptr;

}

/*
 * get_word -- extract word from a line
 */
void get_word(char *line)
{
	char *ptr;
	ptr = line;
	char word[32];
	int i, j;

	j = 0;

	while (*ptr != '\0') {
		// We should clear the buf and counter
		bzero(word, sizeof(word));
		i = 0;
		while (('A' <= *ptr && *ptr <= 'Z') || ('a' <= *ptr &&
		    *ptr <= 'z')) {
			word[i] = *ptr;
			i++;
			ptr++;
		}
		if (word[0] != 0) {
			printf("%s\n", word);
			j++;
		}
		ptr++;

	}
	printf("The total number is %d\n", j);

}

/*
 * get_number -- extract number from a line
 */
void get_number(char *line)
{
	char *ptr;
	ptr = line;
	char num[32];
	int i, j;

	j = 0;

	while (*ptr != '\0') {
		// We should clear the buf and counter
		bzero(num, sizeof(num));
		i = 0;
		while ('0' <= *ptr && *ptr <= '9') {
			num[i] = *ptr;
			i++;
			ptr++;
		}
		if (num[0] != 0) {
			printf("%s\n", num);
			j++;
		}
		ptr++;

	}
	printf("The total number is %d\n", j);

}

/*
 * get_comment -- extract comments from aline
 */
void get_comment(char *line)
{
	char *ptr;
	ptr = line;
	char comment[1024];
	int i, j;

	j = 0;

	while (*ptr != '\0') {
		// We should clear the buf and counter
		bzero(comment, sizeof(comment));
		i = 0;
		if (*ptr == '#') {
			while (*ptr != '\n') {
				comment[i] = *ptr;
				i++;
				ptr++;
				if (*ptr == '\0')
					break;
			}
		}
		if (comment[0] != 0) {
			printf("%s\n", comment);
			j++;
		}
		ptr++;

	}
	printf("The total comment is %d\n", j);

}

/*
 * clean_space -- clean all space of a line
 */
char *clean_space(char *line)
{
	size_t len = strlen(line);
	//At least, our buf should not small than the line
	char *buf = (char *)malloc(len + 1);
	char *ptr;
	ptr = line;
	int i = 0;

	// XXX It's very import to zero the buf
	memset(buf, 0, len + 1);
	while (*ptr != '\0') {
		while (*ptr == ' ') {
			ptr++;
			if (*(ptr + 1) == '\0')
				break;
		}
		buf[i] = *ptr;
		ptr++;
		i++;

	}

	return buf;
}

/*
 * clean_comment -- clean all comment of a line
 */
char *clean_comment(char *line)
{
	size_t len = strlen(line);
	//At least, our buf should not small than the line
	char *buf = (char *)malloc(len + 1);
	char *ptr;
	ptr = line;
	int i = 0;

	// XXX It's very import to zero the buf
	memset(buf, 0, len + 1);
	while (*ptr != '\0') {
		if (*ptr == '#')
			break;

		buf[i] = *ptr;
		ptr++;
		i++;

	}
	ptr = buf;

	return ptr;
}

// read_file, read full of file contents and
// store into buf
char *read_file(const char *filename)
{
	int fd;
	struct stat file_info;
	char *buffer;
	size_t len;
	/*  Open the file */
	fd = open(filename, O_RDONLY);
	if (fd < 0) {
		fprintf(stderr, "Failed to open the file!\n");
		exit(-1);
	}
	/* Get infomation about the file */
	fstat(fd, &file_info);
	len = file_info.st_size;
	//printf("The length of file is %d\n", len);
	/* Make sure the file is an ordinary file. */
	if (!S_ISREG(file_info.st_mode)) {
		close(fd);
		return NULL;
	}
	/* Allocate a buffer large enough to hold the file's contents. */
	buffer = (char *)malloc(len);
	/* Read the file into the buffer. */
	read(fd, buffer, len);
	close(fd);
	return buffer;
}


